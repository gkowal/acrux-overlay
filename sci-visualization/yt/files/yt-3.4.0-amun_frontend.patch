diff --git a/yt/frontends/amun/__init__.py b/yt/frontends/amun/__init__.py
new file mode 100644
index 000000000..0179e391c
--- /dev/null
+++ b/yt/frontends/amun/__init__.py
@@ -0,0 +1,14 @@
+"""
+API for yt.frontends.amun
+
+
+
+"""
+
+#-----------------------------------------------------------------------------
+# Copyright (c) 2013, yt Development Team.
+#
+# Distributed under the terms of the Modified BSD License.
+#
+# The full license is in the file COPYING.txt, distributed with this software.
+#-----------------------------------------------------------------------------
diff --git a/yt/frontends/amun/api.py b/yt/frontends/amun/api.py
new file mode 100644
index 000000000..5f945df0d
--- /dev/null
+++ b/yt/frontends/amun/api.py
@@ -0,0 +1,25 @@
+"""
+API for yt.frontends.amun
+
+
+
+"""
+
+#-----------------------------------------------------------------------------
+# Copyright (c) 2013, yt Development Team.
+#
+# Distributed under the terms of the Modified BSD License.
+#
+# The full license is in the file COPYING.txt, distributed with this software.
+#-----------------------------------------------------------------------------
+
+from .data_structures import \
+      AmunGrid, \
+      AmunHierarchy, \
+      AmunDataset
+
+from .fields import \
+      AmunFieldInfo
+
+from .io import \
+      AmunIOHandler
diff --git a/yt/frontends/amun/data_structures.py b/yt/frontends/amun/data_structures.py
new file mode 100644
index 000000000..fe4cea20f
--- /dev/null
+++ b/yt/frontends/amun/data_structures.py
@@ -0,0 +1,230 @@
+"""
+Amun data structures
+
+
+
+"""
+
+#-----------------------------------------------------------------------------
+# Copyright (c) 2013, yt Development Team.
+#
+# Distributed under the terms of the Modified BSD License.
+#
+# The full license is in the file COPYING.txt, distributed with this software.
+#-----------------------------------------------------------------------------
+
+import os
+import numpy as np
+import weakref
+
+from yt.data_objects.grid_patch import \
+    AMRGridPatch
+from yt.geometry.grid_geometry_handler import \
+    GridIndex
+from yt.data_objects.static_output import \
+    Dataset
+from yt.utilities.file_handler import \
+    HDF5FileHandler, \
+    warn_h5py
+from .fields import AmunFieldInfo
+
+
+class AmunGrid(AMRGridPatch):
+    _id_offset = 0
+    _id_shift  = 0
+
+    def __init__(self, id, index, level, shift):
+        AMRGridPatch.__init__(self, id, filename=index.index_filename,
+                              index=index)
+        self.Parent = None
+        self.Children = []
+        self.Level = level
+        self._id_shift = shift
+
+    def __repr__(self):
+        return "AmunGrid_%04i (%s)" % (self.id, self.ActiveDimensions)
+
+
+class AmunHierarchy(GridIndex):
+    grid = AmunGrid
+
+    def __init__(self, ds, dataset_type='amun_h5'):
+        self.dataset_type = dataset_type
+        self.dataset = weakref.proxy(ds)
+        # for now, the index file is the dataset!
+        self.index_filename = self.dataset.parameter_filename
+        self.directory = os.path.dirname(self.index_filename)
+        # float type for the simulation edges and must be float64 now
+        self.float_type = np.float64
+        self._handle = HDF5FileHandler(self.index_filename)
+        GridIndex.__init__(self, ds, dataset_type)
+
+    def _detect_output_fields(self):
+        self.field_list = [("amun_h5", item) for item in self._handle['/variables']]
+
+    def _count_grids(self):
+        self.num_grids = self._handle['/attributes'].attrs["nleafs"]
+
+    def _parse_index(self):
+        nd = self.dataset.dimensionality
+
+        num_procs  = np.squeeze(self._handle['/attributes'].attrs["nprocs"])
+        num_grids  = np.squeeze(self._handle['/attributes'].attrs["nleafs"])
+        block_dims =            self._handle['/attributes'].attrs["dims"]
+
+        self.grid_left_edge      = np.zeros((num_grids, 3), dtype='float64')
+        self.grid_right_edge     = np.ones ((num_grids, 3), dtype='float64')
+        self.grid_dimensions     = np.zeros((num_grids, 3), dtype='int32')
+        self.grid_particle_count = np.zeros([num_grids, 1], dtype='int64')
+        self.grid_levels         = np.zeros((num_grids, 1), dtype='int32')
+        self.grids               = np.empty( num_grids    , dtype='object')
+
+        n = 0
+        for proc in range(num_procs):
+
+            basedir  = os.path.dirname(self.index_filename)
+            basename = os.path.basename(self.index_filename).split('_')[0]
+            if basedir == '':
+              filename = "%s_%05d.h5" % (basename, proc)
+            else:
+              filename = "%s/%s_%05d.h5" % (basedir, basename, proc)
+
+            handle  = HDF5FileHandler(filename)
+            dblocks = np.squeeze(handle['/attributes'].attrs["dblocks"])
+            bounds  = handle['/coordinates/bounds']
+            levels  = handle["/coordinates/levels"]
+
+            self.dataset.parameter_filename = filename
+            self.index_filename = filename
+            shift = n
+
+            for i in range(dblocks):
+               self.grid_left_edge[n][0:nd]  = np.array(bounds[0,0:nd,i], dtype='float64')
+               self.grid_right_edge[n][0:nd] = np.array(bounds[1,0:nd,i], dtype='float64')
+               self.grid_dimensions[n]       = block_dims[:]
+               self.grid_levels[n][0]        = levels[i] - 1
+               self.grids[n]                 = self.grid(n, self, levels[i] - 1, shift)
+               n += 1
+
+        self.max_level       = np.squeeze(self._handle['/attributes'].attrs["maxlev"])
+
+        self.grid_left_edge  = self.ds.arr(self.grid_left_edge , "code_length")
+        self.grid_right_edge = self.ds.arr(self.grid_right_edge, "code_length")
+
+        if self.dataset.dimensionality <= 2:
+            self.grid_right_edge[:,2] = self.dataset.domain_right_edge[2]
+
+    def _populate_grid_objects(self):
+        for g in self.grids:
+            g._prepare_grid()
+            g._setup_dx()
+
+    def print_stats(self):
+        """
+        Prints out (stdout) relevant information about the simulation
+        """
+        header = "%3s\t%6s\t%14s\t%14s" % ("level","# grids", "# cells",
+                                           "# cells^3")
+        print(header)
+        print("%s" % (len(header.expandtabs())*"-"))
+        for level in range(self.max_level):
+            if (self.level_stats['numgrids'][level]) > 0:
+                print("% 3i\t% 6i\t% 14i\t% 14i" % \
+                      (level, self.level_stats['numgrids'][level],
+                       self.level_stats['numcells'][level],
+                       np.ceil(self.level_stats['numcells'][level]**(1./3))))
+                dx = self.select_grids(level)[0].dds[0]
+        print("-" * 46)
+        print("   \t% 6i\t% 14i" % (self.level_stats['numgrids'].sum(), self.level_stats['numcells'].sum()))
+        print("\n")
+        try:
+            print("z = %0.8f" % (self["CosmologyCurrentRedshift"]))
+        except:
+            pass
+        print("t = %0.8e = %0.8e s = %0.8e years" % \
+            (self.ds.current_time.in_units("code_time"),
+             self.ds.current_time.in_units("s"),
+             self.ds.current_time.in_units("yr")))
+        print("\nSmallest Cell:")
+        for item in ("Mpc", "pc", "AU", "cm"):
+            print("\tWidth: %0.3e %s" % (dx.in_units(item), item))
+
+class AmunDataset(Dataset):
+    _index_class = AmunHierarchy
+    _field_info_class = AmunFieldInfo
+
+    def __init__(self, filename, dataset_type='amun_h5',
+                 storage_filename=None,
+                 units_override=None):
+        self.fluid_types += ('amun_h5',)
+        self._handle = HDF5FileHandler(filename)
+        Dataset.__init__(self, filename, dataset_type,
+                         units_override=units_override)
+        self.storage_filename = storage_filename
+        self.refine_by = 2
+
+    def _set_code_unit_attributes(self):
+        self.length_unit   = self.quan(1.0, "cm")
+        self.mass_unit     = self.quan(1.0, "g")
+        self.time_unit     = self.quan(1.0, "s")
+        self.time_unit     = self.quan(1.0, "s")
+        self.velocity_unit = self.quan(1.0, "cm/s")
+        self.magnetic_unit = self.quan(1.0, "gauss")
+
+    def _parse_parameter_file(self):
+        self.unique_identifier = self.parameter_filename.__hash__()
+        self.refine_by = 2
+        self.field_ordering = 'fortran'
+        dims = self._handle['/attributes'].attrs["dims"]
+        dimensionality = 3
+        if dims[2] == 1:
+          dimensionality = 2
+        self.current_time = self._handle['/attributes'].attrs["time"][0]
+        self.dimensionality = dimensionality
+
+        xmin = np.squeeze(self._handle['/attributes'].attrs["xmin"])
+        xmax = np.squeeze(self._handle['/attributes'].attrs["xmax"])
+        ymin = np.squeeze(self._handle['/attributes'].attrs["ymin"])
+        ymax = np.squeeze(self._handle['/attributes'].attrs["ymax"])
+        zmin = np.squeeze(self._handle['/attributes'].attrs["zmin"])
+        zmax = np.squeeze(self._handle['/attributes'].attrs["zmax"])
+
+        self.domain_left_edge  = np.array([xmin, ymin, zmin], dtype='float64')
+        self.domain_right_edge = np.array([xmax, ymax, zmax], dtype='float64')
+
+        self.domain_width = self.domain_right_edge - self.domain_left_edge
+
+        maxlev = np.squeeze(self._handle['/attributes'].attrs["maxlev"])
+        rdims  = self._handle['/attributes'].attrs["rdims"]
+
+        fdims  = rdims * dims * 2**(maxlev - 1)
+        if dimensionality == 2:
+          fdims[2] = 1
+        self.domain_dimensions = fdims
+
+        self.current_time = np.squeeze(self._handle['/attributes'].attrs["time"])
+
+        self.periodicity = [ True, True, True ]
+        if "periodic" in self._handle['/attributes'].attrs:
+          self.periodicity = self._handle['/attributes'].attrs["periodic"] == 1
+
+        # Cosmological parameters (currently not supported in Amun)
+        #
+        self.cosmological_simulation = 0
+        self.current_redshift        = 0.0
+        self.omega_matter            = 0.0
+        self.omega_lambda            = 0.0
+        self.hubble_constant         = 0.0
+
+    @classmethod
+    def _is_valid(self, *args, **kwargs):
+        warn_h5py(args[0])
+        try:
+            fh = HDF5FileHandler(args[0])
+            if "attributes" in fh["/"].keys() \
+                  and "coordinates" in fh["/"].keys() \
+                  and "variables" in fh["/"].keys():
+                return True
+        except (IOError, OSError, ImportError):
+            pass
+        return False
diff --git a/yt/frontends/amun/definitions.py b/yt/frontends/amun/definitions.py
new file mode 100644
index 000000000..94175d454
--- /dev/null
+++ b/yt/frontends/amun/definitions.py
@@ -0,0 +1 @@
+# This file is often empty.  It can hold definitions related to a frontend.
diff --git a/yt/frontends/amun/fields.py b/yt/frontends/amun/fields.py
new file mode 100644
index 000000000..83bec3ad2
--- /dev/null
+++ b/yt/frontends/amun/fields.py
@@ -0,0 +1,52 @@
+"""
+Amun-specific fields
+
+
+
+"""
+
+#-----------------------------------------------------------------------------
+# Copyright (c) 2013, yt Development Team.
+#
+# Distributed under the terms of the Modified BSD License.
+#
+# The full license is in the file COPYING.txt, distributed with this software.
+#-----------------------------------------------------------------------------
+
+from yt.fields.field_info_container import \
+    FieldInfoContainer
+
+# We need to specify which fields we might have in our dataset.  The field info
+# container subclass here will define which fields it knows about.  There are
+# optionally methods on it that get called which can be subclassed.
+
+
+class AmunFieldInfo(FieldInfoContainer):
+    known_other_fields = (
+        ("dens", ("code_mass/code_length**3", ["density"], None)),
+        ("velx", ("code_length/code_time", ["velocity-x"], None)),
+        ("vely", ("code_length/code_time", ["velocity-y"], None)),
+        ("velz", ("code_length/code_time", ["velocity-z"], None)),
+        ("pres", ("code_pressure", ["pressure"], None)),
+        ("magx", ("code_magnetic", [], None)),
+        ("magy", ("code_magnetic", [], None)),
+        ("magz", ("code_magnetic", [], None)),
+    )
+
+    def __init__(self, ds, field_list):
+        super(AmunFieldInfo, self).__init__(ds, field_list)
+
+    def setup_fluid_fields(self):
+        from yt.fields.magnetic_field import \
+            setup_magnetic_field_aliases
+        unit_system = self.ds.unit_system
+
+        # setup magnetic field
+        #
+        setup_magnetic_field_aliases(self, "amun_h5", ["mag%s" % ax for ax in "xyz"])
+
+        # add kinetic energy
+        #
+        def _kinetic_energy(field, data):
+            return data["amun_h5","dens"] * (data["amun_h5","velx"]**2 + data["amun_h5","vely"]**2 + data["amun_h5","velz"]**2)
+        self.add_field(("amun_h5","ekin"), sampling_type="cell", function=_kinetic_energy,                            units=unit_system["pressure"])
diff --git a/yt/frontends/amun/io.py b/yt/frontends/amun/io.py
new file mode 100644
index 000000000..9369c8634
--- /dev/null
+++ b/yt/frontends/amun/io.py
@@ -0,0 +1,72 @@
+"""
+Amun-specific IO functions
+
+
+
+"""
+
+#-----------------------------------------------------------------------------
+# Copyright (c) 2013, yt Development Team.
+#
+# Distributed under the terms of the Modified BSD License.
+#
+# The full license is in the file COPYING.txt, distributed with this software.
+#-----------------------------------------------------------------------------
+
+import numpy as np
+from yt.utilities.file_handler import \
+    HDF5FileHandler
+from yt.utilities.io_handler import \
+    BaseIOHandler
+
+class AmunIOHandler(BaseIOHandler):
+    _particle_reader = False
+    _dataset_type = 'amun_h5'
+
+    def _read_fluid_selection(self, chunks, selector, fields, size):
+        chunks = list(chunks)
+        rv = {}
+        if size is None:
+            size = sum((grid.count(selector) for chunk in chunks
+                        for grid in chunk.objs))
+
+        if any((ftype != "amun_h5" for ftype, fname in fields)):
+            raise NotImplementedError
+
+        for field in fields:
+            rv[field] = np.empty(size, dtype="float64")
+        ind = 0
+        for chunk in chunks:
+            data = self._read_chunk_data(chunk, fields)
+            for grid in chunk.objs:
+                for field in fields:
+                    ftype, fname = field
+                    ds = data[grid.id].pop(field)
+                    nd = grid.select(selector, ds, rv[field], ind)
+                ind += nd
+                data.pop(grid.id)
+        return rv
+
+    def _read_chunk_data(self, chunk, fields):
+        f = self.ds._handle
+        rv = {}
+        for grid in chunk.objs:
+            rv[grid.id] = {}
+        if len(fields) == 0:
+            return rv
+        for grid in chunk.objs:
+            f = HDF5FileHandler(grid.filename)
+            ng = np.squeeze(f['/attributes'].attrs["nghosts"])
+            dm = np.squeeze(f['/attributes'].attrs["dims"])
+            ib, ie = ng, ng + dm[0]
+            jb, je = ng, ng + dm[1]
+            if grid.ds.dimensionality == 3:
+              kb, ke = ng, ng + dm[2]
+            else:
+              kb, ke = 0, 1
+            for field in fields:
+                ftype, fname = field
+                element = grid.id - grid._id_shift
+                data = f['variables/%s' % fname][kb:ke,jb:je,ib:ie,element].transpose()
+                rv[grid.id][field] = np.asarray(data[...], "float64")
+        return rv
diff --git a/yt/frontends/amun/misc.py b/yt/frontends/amun/misc.py
new file mode 100644
index 000000000..e69de29bb
diff --git a/yt/frontends/api.py b/yt/frontends/api.py
index 9ffa7f6e6..33a1eb69f 100644
--- a/yt/frontends/api.py
+++ b/yt/frontends/api.py
@@ -18,6 +18,7 @@ from yt.extern.six.moves import cPickle as pickle
 
 _frontends = [
     'ahf',
+    'amun',
     'art',
     'artio',
     'athena',
